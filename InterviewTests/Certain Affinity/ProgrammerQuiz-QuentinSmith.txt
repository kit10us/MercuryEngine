This is Certain Affinity's take-home programming test. It is meant to
test your understanding of basic C/C++ concepts as well as your algorithmic
design sense. Answer each question as well as you can. If you run into any
ambiguity or problems with a question, just include it in your answer and
move on.

Things that we will be considering when reviewing your solutions include:
   * Solutions that are bug-free and solve the given problems
   * Use of algorithms geared towards high performance and minimal resource usage (memory / storage space).
     For example, an O(n) time algorithm with O(1) additional space requirement
     is better than an O(n^2) time algorithm with O(n) space requirement
   * Clear, concise code which is easy to read and understand

For the purposes of this test, all solutions should be written in C++.
Standard C/C++ library functions and containers may be used unless noted otherwise.
Use of any platform-specific libraries or functions should be avoided.
For each coding problem, you are provided with the prototype for the function
that serves as the interface to your solution. You are responsible for implementing
this function and writing any supporting functions and test/verification code.

You are encouraged to include with your solutions any notes, explanations, documentation
and test code that you might have written to support your solutions.
Citing references is fine, but getting direct help on the problems
from others or the Internet is frowned upon.

There is no time limit on how quickly to return this completed test, but
obviously quicker is better. It is anticipated that completing the full
test will take a few hours. Send the completed test back to the email address
from which it was sent to you.

Thank you!

(NOTE: this is best viewed with a monospaced font!)

Q1)    What is the size of this structure, ie: sizeof(class DataBlock) == what?
   Explain your answer.

   class DataBlock
   {
       bool flag;
       int number;
       short small;
       float real;

       void Clear ()
       {
           flag = false;
           number = 0;
           small = 0;
           real = 0;
       }

       virtual const char* GetName ()
       {
           return "DataBlock";
       }

       virtual void Print ()
       {
           printf("DataBlock = {...}");
       }
   };

A1)    The size of a class is generally compiler, target (hardware) specific, as well as determined by the current byte alignment (VC++ pragma pack), order of members, and the existence of a vptr (due to any virtual members).
   My current "goto" compiler (VS2008) will say 20 bytes with a default alignment of 4,
   * 1 byte for the bool (older VC would have it at 4)
   * 3 bytes of padding
   * 4 bytes for the int
   * 2 bytes for the short
   * 2 bytes of padding
   * 4 bytes for the float
   * 4 bytes for the vptr (though, the location of the vptr is also compiler specific)
Optimizations for size without losing speed _could_ be to re-organize the bool next to the short.
Optimizations for size with a possibility of losing speed would be to change byte packing.
Separating the data from the virtual logic, in something like an adapter class (kind of a flyweight?) would move the vptr to another class, which could even be shared.
   

Q2)    Write a single class containing the following to describe a geometric object in a game:

   type (valid values are: Sphere, Box, Cylinder)
   if it's a sphere, a floating point Radius
   if it's a box, a floating point SizeX, SizeY, SizeZ
   if it's a cylinder, a floating point Radius and SizeZ
   boolean Visible flag
   an RGB color value, using 8-bit color channels
   style (valid values are: Wireframe, Shaded)
   Priority value (range 0..4000)

   Minimize the memory size of the structure as best as you can.

A2) See Q2.cpp

Q3)    On some architectures the ability to read/write multiple bytes with
   a single instruction is critical to optimal performance.

   Write a function to efficiently clear a block of memory
   to a specific value. Do not call any external functions like memset().

   Assume that the alignment of the pointer is unknown, and that
   attempts to read/write non-aligned 16 or 32-bit values generate exceptions.

 A3) See Q3.cpp (also included bellow):
   
   void ClearMemory(
       void *buffer,
       unsigned long bufferSizeBytes,
       unsigned char clearValue)
   {
   //  Never done this before: I'm working off of the principal that (from memory, good or bad) a size_t is the native alignment size.
   unsigned char * ucBuffer = static_cast< unsigned char *>( buffer );
   static size_t assumedAlignment = sizeof( size_t ); // Keywords are ok to use, right?
   size_t fillValue( clearValue );
   for ( size_t i = 1; i < assumedAlignment; ++i )
   {
       size_t s = sizeof( unsigned char );
       s <<= 3;
       fillValue <<= s;
       fillValue |= clearValue;
   }

   unsigned char * b = (unsigned char * )&fillValue;

   // First "fast" pass...
   size_t charOffset = 0;

   while( charOffset + assumedAlignment <= bufferSizeBytes )
   {
       size_t * stBuffer = reinterpret_cast< size_t * >( ucBuffer + charOffset );
       *stBuffer = fillValue;
       charOffset += assumedAlignment;
   }

   // Second "slow" pass...
   while( charOffset < bufferSizeBytes )
   {
       ucBuffer[ charOffset ] = clearValue;
       charOffset += sizeof( unsigned char );
   }
   }

I would like to have verified this on different targets for speed improvement over a simple for loop, for example.


Q4)    Write a function which takes as input an integer number,
   and returns that number multiplied by seven (7). For example,
   if the input is 3, a call to this function would return 21.
   The only constraints to your function are:
   1) You cannot use the multiplication operator (ie *, *=) - assume that you
      are developing on a platform with no multiply instruction
   2) You cannot call any other functions
   
   /*
   input: an integer number
   output: the input number multiplied by seven (7)
   for example:
   
   long threeTimesSeven= MultiplyBySeven(3);
   
   assert(threeTimesSeven==21);
   */
   long MultiplyBySeven(long input)
   {
    long times7 = 0;
   for ( long i = 0; i < input; ++i )
   {
       times7 += 7;
   }
   return times7;
   }

Q5)    Write the body for the following function, whose purpose is to duplicate a singly-linked list
   which is passed as input into the function:
   
   Node *LinkedListDuplicate(Node *inputList);
   
   where *inputList is a pointer to the first node in a singly-linked list,
   whose elements each contain an integer value and pointers to two other elements in the list:
   the next link in the list, and some other random element in the list. NOTE: these pointers
   could be NULL, but will never be itself (no self-referencing nodes).
   
   The linked-list node structure is defined as follows:
   
   #include <stdlib.h>
   #include <assert.h>
   
   struct Node
   {
       long value;
       struct Node *nextNode;
       struct Node *randomNode; // can be NULL, will not be self
       
       // these methods should be used for any allocating & deallocating of Node structures
       static struct Node *allocate(void)
       {
           return (struct Node *)malloc(sizeof(struct Node));
       }
       static void deallocate(struct Node *node)
       {
           assert(node!=NULL);
           free(node);
           return;
       }
   };
   
   Given an input linked list, your function should return a functionally
   duplicate copy of the list that has no dependency on the original input list.
   The definition of "functionally duplicate" is that the output list, if
   traversed in order, will contain nodes which, when examined, have the same 'value'
   and values in their  nextNode and randomNode members (or NULL as appropriate)
   as the input list has if traversed in the same order.

   
 A5)
   Node *LinkedListDuplicate(Node *inputList)
   {
       std::map< Node * , Node * > oldToNewMap;

   // Traverse link list creating new nodes.

   // Assumes no circular links.

   Node * current = inputList;

   while( current )

   {

       Node * newNode = Node::allocate();

       newNode->value = current->value;

       oldToNewMap[ current ] = newNode;

       current = current->nextNode;

   }

   // At this point we have an exact duplicate of nodes value wise, and mapping to old, now create the heirarchy.

   current = inputList;

   while( current )

   {

       Node * newCurrent = oldToNewMap[ current ];

       Node * newNext = current->nextNode == 0 ? 0 : oldToNewMap[ current->nextNode ];

       Node * newRandom = current->randomNode == 0 ? 0 : oldToNewMap[ current->randomNode ];

       newCurrent->nextNode = newNext;

       newCurrent->randomNode = newRandom;

       current = current->nextNode;

   }

   return oldToNewMap[ current ];
   }


Q6)    Write the following function to reverse the words in a text string,
   using an algorithm which is as time and space constrained as possible.
   For example, an O(n) time algorithm with O(1) additional space requirement
   would be better than an O(n^2) time algorithm with O(n) space
   requirement. You may use any C/C++ standard library string
   manipulation functions you wish.
   
   /*
   input: a character string consisting of words separated by whitespace
   output: the same string but with the words reversed,
   
   For example:

   char sentence[]= "My name is Chris";
   printf("%s\n", sentence);
   ReverseWords(sentence);
   printf("%s\n", sentence);

   would output:
   My name is Chris
   Chris is name My
   */

A6)

void Reverse( char * first, char * last )
{
   while( first < last )
   {
       std::swap( *first, *last );
       ++first;
       --last;
   }
}

void ReverseWords(char *sentence)
{
   if ( ! sentence )
   {
       return;
   }

   size_t length = strlen( sentence );
   Reverse( sentence, sentence + length - 1 );

   size_t l = 0;
   size_t r = 1;
   while( r < length )
   {
       while( sentence[ r ] != ' ' && sentence[ r ] != 0 )
       {
           char s = sentence[ r ];
           ++r;
       }
       Reverse( sentence + l, sentence + r - 1 );
       l = ++r;
   }
}

EXTRA CREDIT!

Q7) This final question is for extra credit. Answer this one if you want to go the extra mile!
   
   For this problem, you will be writing a function to compute the state of a grid of cellular automata,
   and simulate the state of the grid as time progresses according to a rule set for the birth & death of cells.
   Think of the classic mathematical "game of life" by John Conway.
   The cells are arranged in a rectangular grid.
   Each cell can have as many as 8 neighbors (interior cells) and as few as 3 neighbors (the four corner cells).
   Each cell can have one of two possible states:

   1. alive (occupied)
   2. dead (empty)

   Over the course of the life simulation for your grid, time passes in discrete increments.
   The state of a cell at time N+1 is determined by the state of its neighboring cells at time N.
   For example, in one variation of this simulation, an empty cell becomes 'alive' if exactly 3 of its neighbors
   were 'alive' in the previous time step, and an occupied cell 'dies' if it was surrounded by either
   more than 3 or less than 2 occupied cells. If the state of the cellular automata grid is identical
   across two consecutive time steps then it has reached a steady state.

   To solve this problem, you will write code to determine the state of a cellular automata grid
   at some number of time steps into the future. The prototype for the function you will write is:

   long SimulateLife(
       bool *cellularAutomataGrid,
       long gridWidth,
       long gridHeight,
       long birthRules,
       long deathRules,
       long numberOfTimeSteps);

   Where:

       * cellularAutomataGrid is an array of (gridWidth x gridHeight) cells,
       with some initial population when this function is called.
       A value of 1 or 'true' means 'alive' (occupied); 0 / 'false' means 'dead' (empty).
       For example, the following array: [1, 0, 1, 0, 1, 0, 1, 0, 1] with gridWidth==3 and gridHeight==3
       would correspond to a cellular automata grid which has the following 2-D representation:

             1 0 1
             0 1 0
             1 0 1

       * gridWidth is the width (pitch) of the array of cells
       * gridHeight is the height (row count) of the array of cells
       * birthRules is a bitmask used to determine when empty cells become alive (see below)
       * deathRules is a bitmask used to determine when occupied cells become empty (see below)
       * numberOfTimeSteps is the number of iterations of the life simulation that you should perform the life simulation on the cellularAutomataGrid
       * the function returns the number of time steps of life simulation actually performed,
         which should be equal to numberOfTimeSteps unless the simulation reaches a steady state before then,
         in which case it will may be some value less than numberOfTimeSteps
       * upon exit, cellularAutomataGrid should represent the state of the life simulation after the number of executed time steps

   The rules for birth and death are generalized as bit-masks.
   An empty cell with X occupied neighbors becomes alive in the next time step if (birthRules & (1<<X))!=0.
   An occupied cell with Y occupied neighbors dies in the next time step if (deathRules & (1<<Y))!=0.
   Otherwise, the cell retains its previous state from one time step to the next.
   
   For example, in the version of the simulation described previously, birthRules would be 0x0008 and deathRules would be 0x01F3.

   long SimulateLife(
       bool *cellularAutomataGrid,
       long gridWidth,
       long gridHeight,
       long birthRules,
       long deathRules,
       long numberOfTimeSteps)
   {
       // your answer goes here
   }



THE END